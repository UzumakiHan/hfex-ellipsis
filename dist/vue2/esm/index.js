var e={name:"HfexEllipsis",props:{text:{type:String,default:"",required:!0},maxLines:{type:Number,default:3},width:{type:Number,default:100}},data(){return{expanded:!1,slotBoxWidth:0,showSlotNode:!1,offset:this.text.length,textBoxWidth:this.width}},computed:{boxStyle(){return this.width?{width:`${this.width}%`}:""},realText(){const e=this.offset!==this.text.length;let t=this.text;return e&&!this.expanded&&(t=`${this.text.slice(0,this.offset)}...`),t}},mounted(){const{len:e}=this.getLines();e>this.maxLines&&(this.showSlotNode=!0,this.$nextTick((()=>{this.slotBoxWidth=this.$refs.slotRef.clientWidth,this.textBoxWidth=this.$refs.textOverflow.clientWidth,this.calculateOffset(0,this.text.length)})))},methods:{getLines(){const e=this.$refs.overEllipsis.getClientRects();return{len:e.length,lastWidth:e[e.length-1].width}},isOverflow(){const{len:e,lastWidth:t}=this.getLines();if(e<this.maxLines)return!1;if(this.maxLines){const n=Boolean(e===this.maxLines&&t+this.slotBoxWidth>this.textBoxWidth);if(e>this.maxLines||n)return!0}return!1},calculateOffset(e,t){this.$nextTick((()=>{Math.abs(e-t)<=1||(this.isOverflow()?t=this.offset:e=this.offset,this.offset=Math.floor((e+t)/2),this.calculateOffset(e,t))}))},toggle(){this.expanded=!this.expanded}}};function t(e,t,n,s,i,o,l,a,r,d){"boolean"!=typeof l&&(r=a,a=l,l=!1);const h="function"==typeof n?n.options:n;let f;if(e&&e.render&&(h.render=e.render,h.staticRenderFns=e.staticRenderFns,h._compiled=!0,i&&(h.functional=!0)),s&&(h._scopeId=s),o?(f=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),t&&t.call(this,r(e)),e&&e._registeredComponents&&e._registeredComponents.add(o)},h._ssrRegister=f):t&&(f=l?function(e){t.call(this,d(e,this.$root.$options.shadowRoot))}:function(e){t.call(this,a(e))}),f)if(h.functional){const e=h.render;h.render=function(t,n){return f.call(n),e(t,n)}}else{const e=h.beforeCreate;h.beforeCreate=e?[].concat(e,f):[f]}return n}const n="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function s(e){return(e,t)=>function(e,t){const s=n?t.media||"default":e,l=o[s]||(o[s]={ids:new Set,styles:[]});if(!l.ids.has(e)){l.ids.add(e);let n=t.source;if(t.map&&(n+="\n/*# sourceURL="+t.map.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t.map))))+" */"),l.element||(l.element=document.createElement("style"),l.element.type="text/css",t.media&&l.element.setAttribute("media",t.media),void 0===i&&(i=document.head||document.getElementsByTagName("head")[0]),i.appendChild(l.element)),"styleSheet"in l.element)l.styles.push(n),l.element.styleSheet.cssText=l.styles.filter(Boolean).join("\n");else{const e=l.ids.size-1,t=document.createTextNode(n),s=l.element.childNodes;s[e]&&l.element.removeChild(s[e]),s.length?l.element.insertBefore(t,s[e]):l.element.appendChild(t)}}}(e,t)}let i;const o={};const l=e;var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{ref:"textOverflow",staticClass:"text-overflow",style:e.boxStyle},[n("span",{ref:"overEllipsis"},[e._v(e._s(e.realText))]),e._v(" "),e.showSlotNode?n("span",{ref:"slotRef",staticClass:"slot-box"},[e._t("default",null,{clickToggle:e.toggle,expanded:e.expanded})],2):e._e()])};a._withStripped=!0;const r=t({render:a,staticRenderFns:[]},(function(e){e&&e("data-v-27bdb63d_0",{source:".slot-box[data-v-27bdb63d] {\n  display: inline-block;\n}\n\n/*# sourceMappingURL=index.vue.map */",map:{version:3,sources:["/home/runner/work/hfex-ellipsis/hfex-ellipsis/src/vue/index.vue","index.vue"],names:[],mappings:"AA6HA;EACA,qBAAA;AC5HA;;AAEA,oCAAoC",file:"index.vue",sourcesContent:['<template>\n    <div\n        ref="textOverflow"\n        class="text-overflow"\n        :style="boxStyle"\n    >\n        <span ref="overEllipsis">{{ realText }}</span>\n        <span\n            v-if="showSlotNode"\n            ref="slotRef"\n            class="slot-box"\n        >\n            <slot\n                :click-toggle="toggle"\n                :expanded="expanded"\n            />\n        </span>\n    </div>\n</template>\n\n<script>\nexport default {\n    name: \'HfexEllipsis\',\n    props: {\n        text: {\n            type: String,\n            default: \'\',\n            required: true\n        },\n        maxLines: {\n            type: Number,\n            default: 3\n        },\n        width: {\n            type: Number,\n            default: 100\n        }\n    },\n    data() {\n        return {\n            expanded: false,\n            slotBoxWidth: 0,\n            showSlotNode: false,\n\n            offset: this.text.length,\n            textBoxWidth: this.width\n        };\n    },\n    computed: {\n        boxStyle() {\n            if (this.width) {\n                return {\n                    width: `${this.width}%`\n                };\n            } else {\n                return \'\';\n            }\n        },\n        realText() {\n            // 是否被截取\n            const isCutOut = this.offset !== this.text.length;\n            let realTextDesc = this.text;\n            if (isCutOut && !this.expanded) {\n                realTextDesc = `${this.text.slice(0, this.offset)}...`;\n            }\n            return realTextDesc;\n        }\n    },\n    mounted() {\n        const {len} = this.getLines();\n        if (len > this.maxLines) {\n            this.showSlotNode = true;\n            this.$nextTick(() => {\n                this.slotBoxWidth = this.$refs.slotRef.clientWidth;\n                this.textBoxWidth = this.$refs.textOverflow.clientWidth;\n                this.calculateOffset(0, this.text.length);\n            });\n        }\n    },\n    methods: {\n        getLines() {\n            const clientRects = this.$refs.overEllipsis.getClientRects();\n            return {\n                len: clientRects.length,\n                lastWidth: clientRects[clientRects.length - 1].width\n            };\n        },\n        isOverflow() {\n            const {len, lastWidth} = this.getLines();\n\n            if (len < this.maxLines) {\n                return false;\n            }\n            if (this.maxLines) {\n                // 超出部分 行数 > 最大行数 或则  已经是最大行数但最后一行宽度 + 后面内容超出正常宽度\n                const lastLineOver = Boolean(\n                    len === this.maxLines && lastWidth + this.slotBoxWidth > this.textBoxWidth\n                );\n                if (len > this.maxLines || lastLineOver) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        calculateOffset(from, to) {\n            this.$nextTick(() => {\n                if (Math.abs(from - to) <= 1) {\n                    return;\n                }\n                if (this.isOverflow()) {\n                    to = this.offset;\n                } else {\n                    from = this.offset;\n                }\n                this.offset = Math.floor((from + to) / 2);\n                this.calculateOffset(from, to);\n            });\n        },\n        toggle() {\n            this.expanded = !this.expanded;\n        }\n    }\n};\n<\/script>\n<style scoped lang="scss">\n.slot-box {\n    display: inline-block;\n}\n</style>\n',".slot-box {\n  display: inline-block;\n}\n\n/*# sourceMappingURL=index.vue.map */"]},media:void 0})}),l,"data-v-27bdb63d",false,undefined,!1,s,void 0,void 0);r.install=e=>{e.component(r.name,r)};export{r as default};

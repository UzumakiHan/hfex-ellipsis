import{defineComponent as e,ref as n,computed as t,onMounted as s,nextTick as o}from"vue";var l=e({name:"HfexEllipsis",props:{text:{type:String,required:!0},maxLines:{type:Number,default:3},width:{type:Number,default:100}},setup(e){const l=n(!1),i=n(0),a=n(!1),r=n(),d=n(),c=n(),f=n(e.text.length),u=n(e.width),p=t((()=>e.width?{width:`${e.width}%`}:"")),x=t((()=>{const n=f.value!==e.text.length;let t=e.text;return n&&!l.value&&(t=`${e.text.slice(0,f.value)}...`),t})),v=()=>{const e=d.value.getClientRects();return{len:e.length,lastWidth:e[e.length-1].width}},h=()=>{const{len:n,lastWidth:t}=v();if(n<e.maxLines)return!1;if(e.maxLines){const s=Boolean(n===e.maxLines&&t+i.value>u.value);if(n>e.maxLines||s)return!0}return!1},m=(e,n)=>{o((()=>{Math.abs(e-n)<=1||(h()?n=f.value:e=f.value,f.value=Math.floor((e+n)/2),m(e,n))}))};return s((()=>{const{len:n}=v();n>e.maxLines&&(a.value=!0,o((()=>{i.value=c.value.clientWidth,u.value=r.value.clientWidth,m(0,e.text.length)})))})),{textOverflow:r,slotRef:c,showSlotNode:a,offset:f,expanded:l,slotBoxWidth:i,textBoxWidth:u,boxStyle:p,realText:x,overEllipsis:d,calculateOffset:m,isOverflow:h,getLines:v,toggle:()=>{l.value=!l.value}}}});function i(e,n,t,s,o,l,i,a,r,d){"boolean"!=typeof i&&(r=a,a=i,i=!1);const c="function"==typeof t?t.options:t;let f;if(e&&e.render&&(c.render=e.render,c.staticRenderFns=e.staticRenderFns,c._compiled=!0,o&&(c.functional=!0)),s&&(c._scopeId=s),l?(f=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),n&&n.call(this,r(e)),e&&e._registeredComponents&&e._registeredComponents.add(l)},c._ssrRegister=f):n&&(f=i?function(e){n.call(this,d(e,this.$root.$options.shadowRoot))}:function(e){n.call(this,a(e))}),f)if(c.functional){const e=c.render;c.render=function(n,t){return f.call(t),e(n,t)}}else{const e=c.beforeCreate;c.beforeCreate=e?[].concat(e,f):[f]}return t}const a="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function r(e){return(e,n)=>function(e,n){const t=a?n.media||"default":e,s=c[t]||(c[t]={ids:new Set,styles:[]});if(!s.ids.has(e)){s.ids.add(e);let t=n.source;if(n.map&&(t+="\n/*# sourceURL="+n.map.sources[0]+" */",t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n.map))))+" */"),s.element||(s.element=document.createElement("style"),s.element.type="text/css",n.media&&s.element.setAttribute("media",n.media),void 0===d&&(d=document.head||document.getElementsByTagName("head")[0]),d.appendChild(s.element)),"styleSheet"in s.element)s.styles.push(t),s.element.styleSheet.cssText=s.styles.filter(Boolean).join("\n");else{const e=s.ids.size-1,n=document.createTextNode(t),o=s.element.childNodes;o[e]&&s.element.removeChild(o[e]),o.length?s.element.insertBefore(n,o[e]):s.element.appendChild(n)}}}(e,n)}let d;const c={};const f=l;var u=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{ref:"textOverflow",staticClass:"text-overflow",style:e.boxStyle},[t("span",{ref:"overEllipsis"},[e._v(e._s(e.realText))]),e._v(" "),e.showSlotNode?t("span",{ref:"slotRef",staticClass:"slot-box"},[e._t("default",null,{clickToggle:e.toggle,expanded:e.expanded})],2):e._e()])};u._withStripped=!0;const p=i({render:u,staticRenderFns:[]},(function(e){e&&e("data-v-6fcdb3e7_0",{source:".slot-box[data-v-6fcdb3e7] {\n  display: inline-block;\n}\n\n/*# sourceMappingURL=index.vue.map */",map:{version:3,sources:["/home/runner/work/hfex-ellipsis/hfex-ellipsis/src/vue/index.vue","index.vue"],names:[],mappings:"AAiJA;EACA,qBAAA;AChJA;;AAEA,oCAAoC",file:"index.vue",sourcesContent:['<template>\n    <div\n        ref="textOverflow"\n        class="text-overflow"\n        :style="boxStyle"\n    >\n        <span ref="overEllipsis">{{ realText }}</span>\n        <span\n            v-if="showSlotNode"\n            ref="slotRef"\n            class="slot-box"\n        >\n            <slot\n                :click-toggle="toggle"\n                :expanded="expanded"\n            />\n        </span>\n    </div>\n</template>\n\n<script lang="ts">\nimport {computed, defineComponent, onMounted, ref, nextTick} from \'vue\';\n\nexport default defineComponent({\n    name: \'HfexEllipsis\',\n    props: {\n        text: {\n            type: String,\n            required: true\n        },\n        maxLines: {\n            type: Number,\n            default: 3\n        },\n        width: {\n            type: Number,\n            default: 100\n        }\n    },\n    setup(props) {\n        const expanded = ref(false);\n        const slotBoxWidth = ref(0);\n        const showSlotNode = ref(false);\n        const textOverflow = ref();\n        const overEllipsis = ref();\n        const slotRef = ref();\n        const offset = ref(props.text.length);\n        const textBoxWidth = ref(props.width);\n\n        const boxStyle = computed(() => {\n            if (props.width) {\n                return {\n                    width: `${props.width}%`\n                };\n            } else {\n                return \'\';\n            }\n        });\n        const realText = computed(() => {\n            // 是否被截取\n            const isCutOut = offset.value !== props.text.length;\n            let realTextDesc = props.text;\n            if (isCutOut && !expanded.value) {\n                realTextDesc = `${props.text.slice(0, offset.value)}...`;\n            }\n            return realTextDesc;\n        });\n        const getLines = () => {\n            const clientRects = overEllipsis.value.getClientRects();\n            return {\n                len: clientRects.length,\n                lastWidth: clientRects[clientRects.length - 1].width\n            };\n        };\n        const isOverflow = () => {\n            const {len, lastWidth} = getLines();\n\n            if (len < props.maxLines) {\n                return false;\n            }\n            if (props.maxLines) {\n                // 超出部分 行数 > 最大行数 或则  已经是最大行数但最后一行宽度 + 后面内容超出正常宽度\n                const lastLineOver = Boolean(\n                    len === props.maxLines && lastWidth + slotBoxWidth.value > textBoxWidth.value\n                );\n                if (len > props.maxLines || lastLineOver) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        const calculateOffset = (from, to) => {\n            nextTick(() => {\n                if (Math.abs(from - to) <= 1) {\n                    return;\n                }\n                if (isOverflow()) {\n                    to = offset.value;\n                } else {\n                    from = offset.value;\n                }\n                offset.value = Math.floor((from + to) / 2);\n                calculateOffset(from, to);\n            });\n        };\n\n        const toggle = () => {\n            expanded.value = !expanded.value;\n        };\n\n        onMounted(() => {\n            const {len} = getLines();\n            if (len > props.maxLines) {\n                showSlotNode.value = true;\n                nextTick(() => {\n                    slotBoxWidth.value = slotRef.value.clientWidth;\n                    textBoxWidth.value = textOverflow.value.clientWidth;\n                    calculateOffset(0, props.text.length);\n                });\n            }\n        });\n        return {\n            // text,\n            //   maxLines,\n            //   width,\n            textOverflow,\n            slotRef,\n            showSlotNode,\n            offset,\n            expanded,\n            slotBoxWidth,\n            textBoxWidth,\n            boxStyle,\n            realText,\n            overEllipsis,\n            calculateOffset,\n            isOverflow,\n            getLines,\n            toggle\n        };\n    }\n});\n<\/script>\n<style scoped lang="scss">\n.slot-box {\n    display: inline-block;\n}\n</style>\n',".slot-box {\n  display: inline-block;\n}\n\n/*# sourceMappingURL=index.vue.map */"]},media:void 0})}),f,"data-v-6fcdb3e7",false,undefined,!1,r,void 0,void 0);p.install=e=>{e.component(p.name,p)};export{p as default};
